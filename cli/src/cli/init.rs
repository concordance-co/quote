use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};

use crate::cli::InitArgs;
use crate::cli::helpers::{
    create_engine_venv, detect_engine_python, engine_extra_indexes, engine_version, find_uv,
    install_python_package,
};
use crate::config::{Versions, VersionsData};
use crate::error::CommandExit;

const DEFAULT_MODEL_ID: &str = "modularai/Llama-3.1-8B-Instruct-GGUF";
const HELLO_WORLD_DIR: &str = "mods";
const HELLO_WORLD_FILENAME: &str = "hello_world.py";
const HELLO_WORLD_TEMPLATE: &str = r#"from typing import Any

from quote_mod_sdk.mod import mod
from quote_mod_sdk import ActionBuilder
from quote_mod_sdk import ModEvent, Added

@mod
def hello_world(event: ModEvent, action: ActionBuilder, tokenizer: Any):
    if isinstance(event, Added):
        return action.force_output(tokenizer.encode("hello world!", add_special_tokens=False))
"#;

pub fn handle(args: InitArgs, versions: &VersionsData) -> Result<()> {
    let uv = find_uv()?;

    let shared_wheel_spec = versions.parsed.shared.wheel_url.clone().ok_or_else(|| {
        CommandExit::with_message(
            2,
            "No shared.wheel_url found in versions.toml; use --wheel to provide a package.",
        )
    })?;

    let sdk_wheel_spec = versions.parsed.sdk.wheel_url.clone().ok_or_else(|| {
        CommandExit::with_message(
            2,
            "No sdk.wheel_url found in versions.toml; use --wheel to provide a package.",
        )
    })?;

    let extra_indexes = engine_extra_indexes(&versions.parsed);

    println!("Installing SHARED from {}", shared_wheel_spec);

    let version = engine_version(&versions.parsed);

    let mut python_path = detect_engine_python(&version)?;
    if python_path.is_none() {
        python_path = Some(create_engine_venv(&version)?);
    }

    let python_path = python_path.expect("engine python path must exist after creation");
    install_python_package(
        uv.as_path(),
        &python_path,
        &shared_wheel_spec,
        &extra_indexes,
    )?;

    println!("Installing SDK from {}", sdk_wheel_spec);
    install_python_package(uv.as_path(), &python_path, &sdk_wheel_spec, &extra_indexes)?;

    // Write .env
    let env_contents = build_env_file(&versions.parsed);
    let env_written = write_file_if_needed(&args.env_file, &env_contents, args.force)?;

    // Create mods/hello_world.py starter mod
    let mods_dir = PathBuf::from(HELLO_WORLD_DIR);
    let hello_world_path = mods_dir.join(HELLO_WORLD_FILENAME);
    let hello_written = write_file_if_needed(&hello_world_path, HELLO_WORLD_TEMPLATE, args.force)?;

    // If nothing was written, instruct the user how to override
    if !env_written && !hello_written {
        return Err(CommandExit::with_message(
            1,
            "Both files already exist. Use --force to overwrite.",
        )
        .into());
    }

    // Emit per-file status
    if env_written {
        println!("Wrote {}", args.env_file.display());
    } else {
        println!("Skipped existing {}", args.env_file.display());
    }

    if hello_written {
        println!("Wrote {}", hello_world_path.display());
    } else {
        println!("Skipped existing {}", hello_world_path.display());
    }

    Ok(())
}

fn write_file_if_needed(path: &Path, contents: &str, force: bool) -> Result<bool> {
    if path.exists() && !force {
        return Ok(false);
    }

    if let Some(parent) = path.parent()
        && !parent.as_os_str().is_empty()
    {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    fs::write(path, contents).with_context(|| format!("Failed to write {}", path.display()))?;
    Ok(true)
}

fn build_env_file(versions: &Versions) -> String {
    let release = &versions.release_version;

    let mut lines = Vec::new();
    lines.push(format!("# Generated by concai-cli {release}"));
    lines.push(format!("CONCAI_MODEL_ID={DEFAULT_MODEL_ID}"));
    lines.push("HF_TOKEN=".to_string());
    lines.push("HF_HUB_VERBOSITY=info".to_string());

    let mut output = lines.join("\n");
    output.push('\n');
    output
}
